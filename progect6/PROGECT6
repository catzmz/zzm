from Crypto.Util.number import getPrime, getRandomRange
from Crypto.Hash import SHA256
import random


class Paillier:
    def __init__(self, key_length=1024):
        p = getPrime(key_length // 2)
        q = getPrime(key_length // 2)
        self.n = p * q
        self.n_sq = self.n ** 2
        self.g = self.n + 1  # 标准简化选择
        self.lam = (p - 1) * (q - 1)
        self.mu = pow(self.lam, -1, self.n)
        self.pk = self.n
        self.sk = (self.lam, self.mu)

    def encrypt(self, m):
        r = getRandomRange(1, self.n)
        return (pow(self.g, m, self.n_sq) * pow(r, self.n, self.n_sq)) % self.n_sq

    def decrypt(self, c):
        return (pow(c, self.lam, self.n_sq) - 1) // self.n * self.mu % self.n


def hash_to_group(element, p):
    h = SHA256.new(element.encode()).hexdigest()
    return pow(int(h, 16), 1, p)


class PrivateIntersectionSum:
    def __init__(self):
        self.p = getPrime(256)  # 安全素数
        self.paillier = Paillier()

    def setup(self):
        self.k1 = random.randint(1, self.p - 1)
        return self.paillier.pk

    def party1_round1(self, V):
        self.V = V
        self.V_prime = [pow(hash_to_group(v, self.p), self.k1, self.p) for v in V]
        random.shuffle(self.V_prime)
        return self.V_prime

    def party2_round2(self, V_prime, W):
        self.k2 = random.randint(1, self.p - 1)
        self.Z = [pow(v, self.k2, self.p) for v in V_prime]

        processed_W = []
        for w, t in W:
            h_w = hash_to_group(w, self.p)
            w_k2 = pow(h_w, self.k2, self.p)
            enc_t = self.paillier.encrypt(t)
            processed_W.append((w_k2, enc_t))

        random.shuffle(self.Z)
        random.shuffle(processed_W)
        return self.Z, processed_W

    def party1_round3(self, Z, processed_W):
        intersection_sum = 0
        enc_sum = self.paillier.encrypt(0)

        for w_k2, enc_t in processed_W:
            w_k1k2 = pow(w_k2, self.k1, self.p)
            if w_k1k2 in Z:
                enc_sum = (enc_sum * enc_t) % self.paillier.n_sq

        return enc_sum

    def decrypt_sum(self, enc_sum):
        return self.paillier.decrypt(enc_sum)


# 实验模拟
def google_password_checkup_experiment():
    # 模拟数据
    P1_identifiers = ["user1@example.com", "user2@example.com", "user3@example.com"]
    P2_data = [("user2@example.com", 5), ("user3@example.com", 3), ("user4@example.com", 7)]

    protocol = PrivateIntersectionSum()

    # 准备阶段
    pk = protocol.setup()

    # 第一轮
    V_prime = protocol.party1_round1(P1_identifiers)

    # 第二轮
    Z, processed_W = protocol.party2_round2(V_prime, P2_data)

    # 第三轮
    encrypted_sum = protocol.party1_round3(Z, processed_W)

    # 解密结果
    intersection_sum = protocol.decrypt_sum(encrypted_sum)

    print(f"交集风险总值: {intersection_sum}")
    # 预期输出应为8 (5+3)


if __name__ == "__main__":
    google_password_checkup_experiment()
