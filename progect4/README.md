# PROJECT4:  SM3的软件实现与优化

## 实验要求
1. 基于 **SM3** 的基本软件实现（参考 Project 1 与付勇老师 PPT），逐步优化其执行效率。  
2. 在 SM3 的实现基础上，验证 **Length-Extension Attack（长度扩展攻击）**。  
3. 按照 **RFC6962** 构建包含 100,000 个叶子节点的 **Merkle 树**，并生成叶子节点的 **存在性证明**与**不存在性证明**。

---

## 实验过程

### 1. SM3 基本实现与性能优化
- 使用 `SM3.cpp` 编写 SM3 哈希算法的基础版本，并验证其功能正确性。
- 参考付勇老师 PPT，利用 **SIMD/AVX2** 技术优化，在 `SM3_SIMD.cpp` 中实现高效版本。

---

### 2. Length-Extension Attack 实现

#### 攻击原理
SM3 采用 **Merkle–Damgård** 构造，处理块大小为 512 bit，每次压缩输出 256 bit。由于其内部状态与哈希输出等价，攻击者可利用已知哈希值和消息长度构造伪造数据，而无需知道原始消息明文或密钥。

填充规则：
1. 在消息末尾追加单字节 `0x80`。
2. 追加若干字节 `0x00` 直到消息长度（含 64 位长度域）是 512 bit 的整数倍。
3. 追加原始消息的比特长度（64 位，大端）。

#### 攻击流程
1. 计算合法消息 `key || msg` 的哈希值 `H`（服务器端）。
2. 攻击者已知 `H` 和消息长度 `L`，构造标准填充，并将 `H` 作为初始内部状态。
3. 压缩扩展数据 `extension`，生成伪造哈希 `H'`。
4. 服务器对 `key || msg || padding || extension` 计算哈希 `legitimate_hash`。
5. 若 `H' == legitimate_hash`，则攻击成功。

#### 代码验证
在 `SM3_attack.cpp` 中输出：
- 原始哈希
- 伪造哈希
- 合法哈希
并打印攻击结果。

---

### 3. Merkle 树构建与证明

#### 构建方法
- **叶子哈希**：`leaf_hash = SM3(0x00 || data)`（前缀 `0x00` 区分叶子节点）。
- **内部节点哈希**：`node_hash = SM3(0x01 || left_hash || right_hash)`（前缀 `0x01` 区分内部节点）。
- 若当前层节点数为奇数，则复制最后一个节点以保持偶数。
- 树高约为 `ceil(log2(N))`，当 `N=100,000` 时约 17 层。
- 每层批量计算哈希以提高构建速度。

#### 存在性证明
- 证明路径包含从叶子到根的兄弟节点哈希及左右位置标记。
- 验证时从 `leaf_hash` 出发，按路径依次计算父节点哈希，直至根节点，与存储的根哈希比对。
- 路径长度约等于树高，证明大小约为 `树高 × 32 bytes`。

#### 不存在性证明
- 在有序叶子列表中定位目标数据的插入位置。
- 生成该位置相邻叶子的存在性证明，间接证明目标数据不存在。

#### 代码验证
在 `SM3_MT.cpp` 中输出：
- 根哈希
- 存在性证明验证结果
- 不存在性证明验证结果

---

## 实验结果

### 1. SM3 基本版本运行结果
![SM3 基本版运行结果](pic/SM3_res.png)

### 2. SIMD 优化版本运行结果
![SM3 SIMD 优化运行结果](pic/SM3_SIMD.png)

### 3. Length-Extension Attack 运行结果
![Length-Extension Attack 运行结果](pic/SM3_attack.png)

### 4. Merkle 树运行结果
![Merkle Tree 运行结果](pic/SM3_MT.png)

